{
  "name": "Sequential_Sanitizer_Hardened_v0.3_logging and architecture changes",
  "nodes": [
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.3,
      "position": [
        64,
        -1008
      ],
      "id": "98e4e4cd-029b-4151-b496-452f5ee3032e",
      "name": "When chat message received",
      "webhookId": "fc047cb1-9f7a-4278-b3da-1fe3d4ddda95"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Build_Sanitized_NDJSON - strict mode for config values\n * UPDATED: Uses output_text from Final Decision as primary source\n */\n\nfunction err(msg){ throw new Error(msg); }\n\nfunction simpleHash(str){\n  let hash = 0;\n  for (let i = 0; i < str.length; i++){\n    const c = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + c;\n    hash |= 0;\n  }\n  return hash.toString(36);\n}\n\nconst isPlainObject = v => Object.prototype.toString.call(v) === \"[object Object]\";\nfunction firstDefined(...vals){ for (const v of vals) if (v !== undefined && v !== null) return v; return undefined; }\nfunction s(v){ if (v===undefined||v===null) return undefined; const t=String(v); return t.trim()?t:undefined; }\nfunction deepPrune(value,{removeEmptyObjects=false,removeEmptyArrays=false}={}){\n  if (Array.isArray(value)){\n    const arr = value.map(v=>deepPrune(v,{removeEmptyObjects,removeEmptyArrays})).filter(v=>v!==undefined);\n    if (removeEmptyArrays && arr.length===0) return undefined;\n    return arr;\n  }\n  if (isPlainObject(value)){\n    const out = {};\n    for (const [k,v] of Object.entries(value)){\n      const pruned = deepPrune(v,{removeEmptyObjects,removeEmptyArrays});\n      if (pruned !== undefined) out[k]=pruned;\n    }\n    if (removeEmptyObjects && Object.keys(out).length===0) return undefined;\n    return out;\n  }\n  if (value===null || value===undefined || (typeof value===\"number\" && Number.isNaN(value))) return undefined;\n  return value;\n}\nfunction J(x){ try { return JSON.stringify(x ?? {}); } catch { return \"{}\"; } }\n\nconst items = $input.all();\nif (!items.length) err(\"Build_Sanitized_NDJSON: no input items.\");\n\nconst out = [];\n\nfor (const item of items){\n  const j = item.json || {};\n\n  const san = j.__san || {};\n  const snap = j._pipeline_snapshots || san._pipeline_snapshots || {};\n  const norm = j.normalization || san.normalization || {};\n\n  const pgDecision = j.decision || {};\n  const routing = j.routing || {};\n  const metrics = j.metrics || {};\n  const technical = j.technical || {};\n  const audit = j.audit || {};\n  const messages = j.messages || {};\n\n  const sanitizerDecision = j.sanitizer_decision || {};\n\n  const cfg = j.config || {};\n  const rules = j.rules || {};\n  const thr = j.thresholds || {};\n\n  const sessionId = firstDefined(\n    j.sessionId,\n    san.sessionId,\n    j.chat_payload?.sessionId\n  ) || \"unknown\";\n  \n  const action = firstDefined(\n    j.action,\n    san.action,\n    j.chat_payload?.action\n  ) || \"sendMessage\";\n\n  const originalInput = s(firstDefined(\n    snap.beforeSanitization,\n    norm?.original,\n    san.chat_payload?.chatInput,\n    j.audit?.originalPrompt\n  )) || \"N/A\";\n\n  const normalizedInput = s(firstDefined(\n    snap.input_normalized,\n    norm?.canonical,\n    norm?.normalized,\n    originalInput\n  )) || originalInput;\n\n  const sanitizedText = s(firstDefined(\n    snap.afterSanitization,\n    san.chat_payload?.chatInput,\n    j.chat_payload?.chatInput\n  ));\n\n  const redactedText = s(firstDefined(\n    snap.afterPII,\n    sanitizedText\n  ));\n\n  const pgShouldBlock = !!(routing.shouldBlock || j._isBlocked);\n  const pgShouldWarn = !!(routing.shouldWarn || j._requiresSanitization);\n  const pgIsSafe = !!(routing.isSafe || j._shouldContinue);\n  \n  const sanitizerDecisionStr = sanitizerDecision.decision || 'ALLOW';\n  const sanitizerBlocked = (sanitizerDecisionStr === 'BLOCK');\n  \n  let finalStatus;\n  if (pgShouldBlock || sanitizerBlocked) {\n    finalStatus = \"BLOCKED\";\n  } else if (pgShouldWarn) {\n    finalStatus = \"SANITIZED\";\n  } else {\n    finalStatus = \"ALLOWED\";\n  }\n\n  const shouldBlock = (finalStatus === \"BLOCKED\");\n  const shouldWarn = (finalStatus === \"SANITIZED\");\n  const isSafe = (finalStatus === \"ALLOWED\");\n\n  // âœ“ UPDATED: Priorytet dla output_text z Final Decision\n  const finalOutput = s(j.output_text) || \n                      (shouldBlock \n                        ? (s(messages?.user) || s(cfg?.enforcement?.block_message) || \"Content blocked by security policy\")\n                        : (redactedText || sanitizedText || s(j.chat_payload?.chatInput) || \"N/A\"));\n\n  const pgHasDecision = !!(pgDecision && (pgDecision.action !== undefined || pgDecision.severity !== undefined || pgDecision.scoreRaw !== undefined));\n  const blockedByPG = shouldBlock && pgHasDecision;\n  const blockedBySan = shouldBlock && !pgHasDecision;\n\n  let source = \"sanitizer_pre_pg\";\n  let actionTaken = firstDefined(pgDecision.action, finalStatus);\n  \n  if (finalStatus === \"BLOCKED\"){\n    if (blockedBySan) { \n      source = \"sanitizer_only\"; \n      actionTaken = \"BLOCK_BY_SANITIZER\"; \n    }\n    if (blockedByPG) { \n      source = \"prompt_guard\"; \n      actionTaken = pgDecision.action || \"BLOCK_BY_PROMPT_GUARD\"; \n    }\n  } else {\n    source = pgHasDecision ? \"prompt_guard\" : \"sanitizer_pre_pg\";\n    if (finalStatus === \"ALLOWED\") actionTaken = \"ALLOW\";\n    if (finalStatus === \"SANITIZED\") actionTaken = actionTaken || \"SANITIZE\";\n  }\n\n  const nd = {\n    sessionId,\n    action,\n    chat_payload: {\n      sessionId,\n      action,\n      chatInput: finalOutput\n    },\n    sanitizer: {\n      decision: sanitizerDecisionStr,\n      removal_pct: san.enforcement?.removalPct ?? j.enforcement?.removalPct ?? 0,\n      mode: san.enforcement?.mode || j.enforcement?.mode,\n      score: j.score || sanitizerDecision.score || 0,\n      breakdown: j.scoreBreakdown || sanitizerDecision.scoreBreakdown || {}\n    },\n    prompt_guard: pgHasDecision ? {\n      score: pgDecision.scoreRaw || metrics.injectionScore,\n      score_percent: pgDecision.scorePercent || metrics.scorePercent,\n      risk_level: pgDecision.riskLevel,\n      severity: pgDecision.severity,\n      action: pgDecision.action,\n      should_block: pgShouldBlock,\n      should_warn: pgShouldWarn,\n      is_safe: pgIsSafe,\n      confidence: metrics.confidence,\n      thresholds_used: technical.thresholdsUsed,\n      policies_used: technical.policiesUsed,\n      timestamp: audit.timestamp\n    } : {},\n    final_decision: {\n      status: finalStatus,\n      blocked: shouldBlock,\n      sanitized: shouldWarn,\n      allowed: isSafe,\n      action_taken: actionTaken,\n      user_message: s(messages?.user) || \"\",\n      internal_note: s(messages?.internal) || \"\",\n      source\n    },\n    pipeline_flow: {\n      input_raw: originalInput,\n      input_normalized: normalizedInput,\n      after_sanitization: sanitizedText || finalOutput,\n      after_pii_redaction: redactedText || finalOutput,\n      output_final: finalOutput,\n      output_status: finalStatus\n    },\n    scoring: {\n      sanitizer_score: Number(j.score ?? sanitizerDecision.score ?? 0),\n      prompt_guard_score: pgDecision.scoreRaw || metrics.injectionScore,\n      prompt_guard_percent: pgDecision.scorePercent || metrics.scorePercent,\n      combined_severity: firstDefined(\n        pgDecision.severity,\n        (j.score ?? 0) >= 76 ? 5 :\n        (j.score ?? 0) >= 56 ? 4 :\n        (j.score ?? 0) >= 30 ? 3 :\n        (j.score ?? 0) >= 10 ? 2 : 1\n      ),\n      score_breakdown: j.scoreBreakdown || sanitizerDecision.scoreBreakdown || {},\n      match_details: j.matchDetails || []\n    },\n    config_metadata: {\n      config_hash: (cfg && rules && thr) ? simpleHash(JSON.stringify({ cfg, rules, thr })) : \"no-config\",\n      config_version: cfg?.version || \"unknown\",\n      has_full_config: !!(cfg && rules && thr),\n      has_prompt_guard: pgHasDecision,\n      config_ref: {\n        normalization_unicode: cfg.normalization?.unicode_form,\n        scoring_ranges: thr?.ranges,\n        prompt_guard_thresholds: technical.thresholdsUsed\n      },\n      loader_info: j._loader\n    },\n    _audit: {\n      processing_timestamp: new Date().toISOString(),\n      pipeline_version: \"v2.2-merged\",\n      total_processing_time: metrics.processingTime,\n      final_action: actionTaken\n    }\n  };\n\n  const ndClean = deepPrune(nd);\n\n  const row = {\n    sessionId: ndClean.sessionId,\n    action: ndClean.action,\n    timestamp: ndClean._audit?.processing_timestamp,\n\n    original_input: ndClean.pipeline_flow?.input_raw,\n    normalized_input: ndClean.pipeline_flow?.input_normalized,\n    after_sanitization: ndClean.pipeline_flow?.after_sanitization,\n    after_pii_redaction: ndClean.pipeline_flow?.after_pii_redaction,\n    chat_input: ndClean.chat_payload?.chatInput,\n    result: ndClean.pipeline_flow?.output_final,\n\n    threat_score: ndClean.scoring?.prompt_guard_score ?? 0,\n    threat_severity: ndClean.prompt_guard?.risk_level ?? \"UNDEFINED\",\n    pg_score: ndClean.prompt_guard?.score ?? 0,\n    pg_score_percent: ndClean.prompt_guard?.score_percent ?? 0,\n    final_status: ndClean.final_decision?.status ?? \"UNKNOWN\",\n    final_action: ndClean._audit?.final_action ?? \"\",\n    user_message: ndClean.final_decision?.user_message ?? \"\",\n\n    removal_pct: ndClean.sanitizer?.removal_pct ?? 0,\n    threat_labels: [],\n    threat_matches: [],\n\n    config_version: ndClean.config_metadata?.config_version,\n    config_hash: ndClean.config_metadata?.config_hash,\n    pipeline_version: ndClean._audit?.pipeline_version,\n    processing_time_ms: ndClean._audit?.total_processing_time ?? 0,\n\n    sanitizer_json: J(ndClean.sanitizer),\n    prompt_guard_json: J(ndClean.prompt_guard),\n    scoring_json: J(ndClean.scoring),\n    final_decision_json: J(ndClean.final_decision),\n    pipeline_flow_json: J(ndClean.pipeline_flow),\n    config_metadata_json: J(ndClean.config_metadata),\n    raw_event: J(ndClean)\n  };\n\n  out.push({ json: { ndjson: ndClean, row } });\n}\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5632,
        -976
      ],
      "id": "23cf28c5-5730-4249-9d4c-aa67e8a34432",
      "name": "Build+Sanitize NDJSON"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=http://clickhouse:8123/?date_time_input_format=best_effort&input_format_skip_unknown_fields=1&query=INSERT%20INTO%20n8n_logs.events_processed%20FORMAT%20JSONEachRow",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendBody": true,
        "contentType": "raw",
        "rawContentType": "application/x-ndjson",
        "body": "={{$json.row}}",
        "options": {
          "response": {
            "response": {
              "fullResponse": true
            }
          },
          "timeout": 15000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        5856,
        -976
      ],
      "id": "e4ffb2be-50e8-4d04-85a5-7d0f16b3c203",
      "name": "Logging to Clikhouse",
      "retryOnFail": true,
      "alwaysOutputData": false,
      "credentials": {
        "httpBasicAuth": {
          "id": "Kjl6uX2sPC73yuGd",
          "name": "Unnamed credential"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * Load_Config - Production version with Bloom validation\n * FIXED: English messages, better error handling, bloom configuration validation\n */\n\nfunction safeParseJson(value, fieldName) {\n  if (value == null) {\n    return { ok: false, error: `${fieldName} is null/undefined` };\n  }\n  \n  if (typeof value === 'object') {\n    return { ok: true, data: value };\n  }\n  \n  if (typeof value === 'string') {\n    try {\n      return { ok: true, data: JSON.parse(value) };\n    } catch (e) {\n      return { ok: false, error: `${fieldName} JSON parse failed: ${e.message}` };\n    }\n  }\n  \n  return { ok: false, error: `${fieldName} has invalid type: ${typeof value}` };\n}\n\nfunction validateAllowlistSchema(obj) {\n  return obj && typeof obj === 'object' && \n    (obj.$schema || obj.title === 'Sanitizer Allowlist Schema');\n}\n\nfunction validateNormalizeConf(text) {\n  return typeof text === 'string' && \n    (/#\\s*normalize\\.conf/i.test(text) || \n     /\\\\u200B=|leet\\.char\\.|# Zero-width|# LEET map/.test(text));\n}\n\nfunction validatePiiConf(obj) {\n  return obj && typeof obj === 'object' && \n    Array.isArray(obj.rules) && \n    obj.rules.length > 0 &&\n    obj.rules.some(r => r && typeof r.pattern === 'string' && typeof r.name === 'string');\n}\n\nfunction validateThresholds(obj) {\n  return obj && typeof obj === 'object' && \n    obj.ranges && \n    obj.ranges.allow && \n    obj.ranges.block;\n}\n\nfunction validateUnifiedConfig(obj) {\n  return obj && typeof obj === 'object' && \n    obj.normalization && \n    obj.sanitization && \n    obj.scoring;\n}\n\nfunction validateRules(obj) {\n  return obj && typeof obj === 'object' && \n    obj.categories && \n    typeof obj.categories === 'object';\n}\n\nfunction validateBloomConfig(config) {\n  const warnings = [];\n  \n  if (!config.bloom || typeof config.bloom !== 'object') {\n    warnings.push('Missing or invalid bloom configuration, using defaults');\n  }\n  \n  if (!config.prefilter || typeof config.prefilter !== 'object') {\n    warnings.push('Missing or invalid prefilter configuration, using defaults');\n  }\n  \n  if (config.prefilter && !Array.isArray(config.prefilter.dangerous_patterns)) {\n    warnings.push('Missing dangerous_patterns in prefilter, will use defaults');\n  }\n  \n  if (!config.bloom_decisions || typeof config.bloom_decisions !== 'object') {\n    warnings.push('Missing bloom_decisions, using defaults');\n  }\n  \n  return warnings;\n}\n\nconst inputItems = $input.all();\nif (!inputItems || !inputItems.length) {\n  console.error('Load_Config: No input items');\n  return [{\n    json: {\n      error: 'No input items',\n      configError: true,\n      decision: { decision: 'ALLOW', reason: 'CONFIG_ERROR' }\n    }\n  }];\n}\n\nconst firstItem = inputItems[0];\nconst j = firstItem.json ? JSON.parse(JSON.stringify(firstItem.json)) : {};\n\nj._loader = {\n  sources: {},\n  missing: [],\n  errors: [],\n  warnings: []\n};\n\nconst data1Result = safeParseJson(j.data1, 'data1 (allowlist_schema)');\nif (data1Result.ok && validateAllowlistSchema(data1Result.data)) {\n  j.allowlist_schema = data1Result.data;\n  j._loader.sources.allowlist_schema = 'json.data1';\n} else {\n  j._loader.missing.push('allowlist_schema');\n  j._loader.errors.push(data1Result.error || 'data1: invalid allowlist_schema');\n}\n\nif (validateNormalizeConf(j.data2)) {\n  j.normalization_text = j.data2;\n  j._loader.sources.normalize_conf = 'json.data2';\n} else {\n  j._loader.missing.push('normalize_conf');\n  j._loader.errors.push('data2: invalid normalize.conf format');\n}\n\nconst data3Result = safeParseJson(j.data3, 'data3 (pii.conf)');\nif (data3Result.ok && validatePiiConf(data3Result.data)) {\n  j.pii_conf = data3Result.data;\n  j.pii_text = typeof j.data3 === 'string' ? j.data3 : JSON.stringify(data3Result.data);\n  j._loader.sources.pii_conf = 'json.data3';\n} else {\n  j._loader.missing.push('pii_conf');\n  j._loader.errors.push(data3Result.error || 'data3: invalid pii.conf format');\n}\n\nconst data4Result = safeParseJson(j.data4, 'data4 (thresholds)');\nif (data4Result.ok && validateThresholds(data4Result.data)) {\n  j.thresholds = data4Result.data;\n  j._loader.sources.thresholds = 'json.data4';\n} else {\n  j._loader.missing.push('thresholds');\n  j._loader.errors.push(data4Result.error || 'data4: invalid thresholds format');\n}\n\nconst data5Result = safeParseJson(j.data5, 'data5 (unified_config)');\nif (data5Result.ok && validateUnifiedConfig(data5Result.data)) {\n  j.config = data5Result.data;\n  j._loader.sources.unified_config = 'json.data5';\n  \n  // Validate bloom configuration and collect warnings\n  const bloomWarnings = validateBloomConfig(j.config);\n  if (bloomWarnings.length > 0) {\n    j._loader.warnings = j._loader.warnings.concat(bloomWarnings);\n    console.warn('Bloom config warnings:', bloomWarnings);\n  }\n  \n  // Ensure bloom configuration has required structure\n  if (!j.config.bloom) {\n    j.config.bloom = { m: 32768, k: 5, seed: 1337, match_mod: 97, min_matched_bits: 2 };\n  }\n  \n  if (!j.config.prefilter) {\n    j.config.prefilter = { \n      ngram: { min: 3, max: 6, prefix_window: 96 },\n      sample_limit: 800,\n      obf_signals: { min_count: 2 },\n      dangerous_patterns: []\n    };\n  } else if (!j.config.prefilter.dangerous_patterns) {\n    j.config.prefilter.dangerous_patterns = [];\n  }\n  \n  if (!j.config.bloom_decisions) {\n    j.config.bloom_decisions = {\n      route_to_ac_threshold: 10,\n      hard_block_threshold: 50,\n      require_zusatz_signals: true\n    };\n  }\n  \n  j.config.references = Object.assign({}, j.config.references || {}, {\n    rules_file: 'rules.config.json',\n    thresholds_file: 'thresholds.config.json',\n    normalize_conf: 'normalize.conf',\n    pii_conf: 'pii.conf'\n  });\n} else {\n  j._loader.missing.push('unified_config');\n  j._loader.errors.push(data5Result.error || 'data5: invalid unified_config format');\n}\n\nconst data6Result = safeParseJson(j.data6, 'data6 (rules)');\nif (data6Result.ok && validateRules(data6Result.data)) {\n  j.rules = data6Result.data;\n  j._loader.sources.rules = 'json.data6';\n} else {\n  j._loader.missing.push('rules');\n  j._loader.errors.push(data6Result.error || 'data6: invalid rules format');\n}\n\nif (j._loader.missing.length > 0) {\n  console.error('Load_Config: Missing required files:', j._loader.missing);\n  console.error('Error details:', j._loader.errors);\n  if (j._loader.warnings.length > 0) {\n    console.warn('Config warnings:', j._loader.warnings);\n  }\n  \n  return [{\n    json: {\n      ...j,\n      configError: true,\n      decision: { decision: 'ALLOW', reason: 'CONFIG_ERROR' },\n      error_message: `Missing required files: ${j._loader.missing.join(', ')}`\n    },\n    pairedItem: 0\n  }];\n}\n\nif (j._loader.warnings.length > 0) {\n  console.info('Config loaded with warnings:', j._loader.warnings);\n}\n\nreturn [{ json: j, pairedItem: 0 }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        -976
      ],
      "id": "8e7b994a-51a9-4968-baa2-2492a9e97996",
      "name": "Config Loader"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "numberInputs": 7,
        "options": {
          "includeUnpaired": true
        }
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1376,
        -992
      ],
      "id": "aeaafe1c-87df-4a30-b8ee-1728e56f3cd3",
      "name": "Merge"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "b247b37b-2208-4363-96d6-d103476087a7",
              "name": "chat_payload",
              "value": "={{$json}}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        416,
        -1008
      ],
      "id": "3d2687cd-04bf-41f5-b61d-a794277adffb",
      "name": "Keep only set"
    },
    {
      "parameters": {
        "operation": "fromJson",
        "destinationKey": "data1",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        976,
        -784
      ],
      "id": "d6283a39-a663-4c10-857d-eeb373a88ba1",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "operation": "text",
        "destinationKey": "data2",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        976,
        -592
      ],
      "id": "065de98c-87e6-413b-b86d-1a9eeb81ec53",
      "name": "Extract from File1"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Normalize_Node - Production version\n * FIXED: Added items declaration, English messages\n */\n\nfunction parseNormalizeConf(confText) {\n  const lines = (confText || \"\").split(/\\r?\\n/);\n  const map = new Map();\n  const leetChar = new Map();\n  const leetSingle = new Map();\n\n  for (const raw of lines) {\n    const line = raw.trim();\n    if (!line || line.startsWith(\"#\")) continue;\n    let m;\n    if ((m = line.match(/^leet\\.single\\.([^=]+)=(.*)$/))) {\n      leetSingle.set(m[1], m[2]);\n      continue;\n    }\n    if ((m = line.match(/^leet\\.char\\.([^=]+)=(.*)$/))) {\n      leetChar.set(m[1], m[2]);\n      continue;\n    }\n    const eq = line.indexOf(\"=\");\n    if (eq >= 0) {\n      const lhs = line.slice(0, eq);\n      const rhs = line.slice(eq + 1) || '';\n      const from = lhs.replace(/\\\\u\\{?([0-9A-Fa-f]{4,6})\\}?/g, (_, h) =>\n        String.fromCodePoint(parseInt(h, 16)),\n      );\n      const to = rhs.replace(/\\\\u\\{?([0-9A-Fa-f]{4,6})\\}?/g, (_, h) =>\n        String.fromCodePoint(parseInt(h, 16)),\n      );\n      map.set(from, to);\n    }\n  }\n  return { map, leetChar, leetSingle };\n}\n\nfunction stripZeroWidth(s) {\n  return s.replace(/[\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\uFEFF]/g, \"\");\n}\n\nfunction collapseWhitespace(s) {\n  return s.replace(/\\s+/g, \" \").trim();\n}\n\nfunction hasMathAlnumSymbols(s) {\n  for (const ch of s) {\n    const cp = ch.codePointAt(0);\n    if (cp >= 0x1D400 && cp <= 0x1D7FF) return true;\n  }\n  return false;\n}\n\nfunction hasMixedLatinCyrillic(s) {\n  let latin = false, cyr = false;\n  for (const ch of s) {\n    const cp = ch.codePointAt(0);\n    if (\n      (cp >= 0x0041 && cp <= 0x007A) ||\n      (cp >= 0x00C0 && cp <= 0x024F)\n    ) latin = true;\n    if ((cp >= 0x0400 && cp <= 0x04FF) || (cp >= 0x0500 && cp <= 0x052F)) cyr = true;\n    if (latin && cyr) return true;\n  }\n  return false;\n}\n\nfunction htmlDecodeIfNeeded(s, decode) {\n  if (!decode) return s;\n  return s\n    .replace(/&nbsp;/g, \" \")\n    .replace(/&amp;/g, \"&\")\n    .replace(/&lt;/g, \"<\")\n    .replace(/&gt;/g, \">\")\n    .replace(/&#(\\d+);/g, (_, d) => String.fromCodePoint(parseInt(d, 10)))\n    .replace(/&#x([0-9A-Fa-f]+);/g, (_, h) => String.fromCodePoint(parseInt(h, 16)));\n}\n\nfunction applyMap(s, mp) {\n  if (!mp || mp.size === 0) return s;\n  const keys = [...mp.keys()].sort((a, b) => b.length - a.length);\n  for (const k of keys) {\n    if (!k) continue;\n    const v = mp.get(k);\n    const re = new RegExp(k.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"), \"g\");\n    s = s.replace(re, v);\n  }\n  return s;\n}\n\nfunction casefold(s) {\n  return s.toLocaleLowerCase(\"en\");\n}\n\nfunction buildSignals(original, beforeHomoglyphMap, afterLeet, final) {\n  const sigs = [];\n\n  if (original.length !== stripZeroWidth(original).length) sigs.push(\"zero-width-removed\");\n  if (hasMathAlnumSymbols(original) || hasMathAlnumSymbols(afterLeet)) sigs.push(\"math-alnum/fraktur\");\n  if (hasMixedLatinCyrillic(original)) sigs.push(\"mixed-latin-cyrillic\");\n  if (/[A-Za-z]/.test(original) && /[0-9]/.test(original) && /[@$%|]/.test(original)) sigs.push(\"leet-like-mix\");\n  \n  const separators = beforeHomoglyphMap.match(/(?:_{3,}|-{3,}|\\.{3,}|={3,}|\\*{3,}){1,}/g);\n  if (separators && separators.length >= 3) sigs.push(\"separator-abuse\");\n\n  if (/(?:<\\|\\/?(system|assistant|user|user_query)\\|>|\\{\\{\\s*system\\s*\\}\\}|\\[\\[\\s*system\\s*\\]\\])/.test(beforeHomoglyphMap)) {\n    sigs.push(\"template-markers\");\n  }\n  \n  return sigs;\n}\n\n// FIXED: Added items declaration\nconst items = $input.all();\nif (!items || items.length === 0) {\n  console.warn('Normalize_Node: No input items');\n  return [];\n}\n\nconst results = [];\n\nfor (const item of items) {\n  const j = item.json ?? {};\n  const cfg = (j.config ?? {});\n  const ncfg = cfg.normalization ?? {};\n  const confText = j.normalization_text || \"\";\n  const { map, leetChar, leetSingle } = parseNormalizeConf(confText);\n\n  const input =\n    j?.chat_payload?.chatInput ??\n    j?.chatInput ??\n    j?.input ??\n    \"\";\n\n  const steps = [];\n  let s = String(input);\n  const original = s;\n\n  s = htmlDecodeIfNeeded(s, !!ncfg.decode_entities);\n  steps.push({ step: \"html_decode\", outLen: s.length });\n\n  try {\n    s = s.normalize(\"NFKC\");\n  } catch {}\n  steps.push({ step: \"nfkc\", outLen: s.length });\n\n  s = casefold(s);\n  steps.push({ step: \"casefold\", outLen: s.length });\n\n  if (ncfg.remove_zero_width !== false) {\n    const s0 = s;\n    s = stripZeroWidth(s);\n    if (s !== s0) steps.push({ step: \"strip_zwsp\", removed: s0.length - s.length });\n  }\n\n  const beforeHomoglyphMap = s;\n\n  s = applyMap(s, map);\n  steps.push({ step: \"homoglyph_map\", outLen: s.length });\n\n  const HEART_PLACEHOLDER = '\\uE000HEART\\uE001';\n  s = s.replace(/<3/g, HEART_PLACEHOLDER);\n  \n  if (leetChar.size) {\n    for (const [k, v] of leetChar.entries()) {\n      if (!k) continue;\n      const re = new RegExp(k.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"), \"g\");\n      s = s.replace(re, v);\n    }\n    steps.push({ step: \"leet.char\", outLen: s.length });\n  }\n  \n  s = s.replace(new RegExp(HEART_PLACEHOLDER, 'g'), '<3');\n\n  const afterLeet = s;\n\n  if (leetSingle.size) {\n    const tokens = s.split(/(\\b)/);\n    for (let i = 0; i < tokens.length; i++) {\n      const t = tokens[i];\n      if (/^\\b$/.test(t)) continue;\n      const mapped = leetSingle.get(t);\n      if (mapped) tokens[i] = mapped;\n    }\n    s = tokens.join(\"\");\n    steps.push({ step: \"leet.single\", outLen: s.length });\n  }\n\n  if (ncfg.collapse_whitespace !== false) {\n    s = collapseWhitespace(s);\n    steps.push({ step: \"collapse_ws\", outLen: s.length });\n  }\n\n  const canonical = s;\n  const forScoring = canonical;\n\n  const signals = buildSignals(original, beforeHomoglyphMap, afterLeet, canonical);\n\n  j._pipeline_snapshots = j._pipeline_snapshots || {};\n  j._pipeline_snapshots.input_raw = original;\n  j._pipeline_snapshots.input_normalized = canonical;\n\n  j.normalization = {\n    original: original,\n    normalized: canonical,\n    canonical: canonical,\n    forScoring: forScoring,\n    steps,\n    obfuscationSignals: signals,\n  };\n\n  j.chat_payload = j.chat_payload || {};\n  j.chat_payload.chatInput = canonical;\n  j.input_raw = original;\n\n  item.json = j;\n  results.push(item);\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2144,
        -976
      ],
      "id": "278c5229-15b7-47a6-9783-de50878bf6c1",
      "name": "Normalize_Node"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "583cd94d-198b-4b10-a901-b4feb6edc51a",
              "name": "sessionId",
              "value": "={{ $('Build+Sanitize NDJSON').item.json.ndjson.chat_payload.sessionId }}",
              "type": "string"
            },
            {
              "id": "998db0bf-ad74-49e7-bbad-7d720cedea60",
              "name": "chatInput",
              "value": "={{ $('Build+Sanitize NDJSON').item.json.ndjson.chat_payload.chatInput }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        6064,
        -976
      ],
      "id": "baacd3de-f7ef-4d0b-9779-becb24802c05",
      "name": "Clean output"
    },
    {
      "parameters": {
        "fileSelector": "=/home/node/config/normalize.conf",
        "options": {
          "mimeType": "application/json",
          "dataPropertyName": "data"
        }
      },
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [
        800,
        -592
      ],
      "id": "8d9d645a-8fe4-4550-9726-564a26a9a5d9",
      "name": "Loading config files *.conf"
    },
    {
      "parameters": {
        "fileSelector": "=/home/node/config/allowlist.schema.json",
        "options": {
          "mimeType": "application/json",
          "dataPropertyName": "data"
        }
      },
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [
        800,
        -784
      ],
      "id": "13716b53-fd7e-4e18-8509-75305aed5df2",
      "name": "Loading config files *.json"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Unified Decision Engine - FIXED: Added items declaration, score validation\n */\n\nfunction nowIsoMs() { return new Date().toISOString(); }\n\nfunction mergeDecision(j, decision, source, extraMeta = {}) {\n  j.decision = j.decision || {};\n  Object.assign(j.decision, {\n    decision: decision,\n    source: source,\n    updated_at: nowIsoMs()\n  });\n  \n  j.__metadata = Object.assign({}, j.__metadata || {}, {\n    final_decision: decision,\n    decision_source: source,\n    ...extraMeta\n  });\n  \n  if (decision === 'BLOCK') {\n    j._isBlocked = true;\n  }\n}\n\n// FIXED: Added items declaration\nconst items = $input.all();\nif (!items || items.length === 0) {\n  console.warn('Unified Decision Engine: No input items');\n  return [];\n}\n\nconst out = [];\n\nfor (const item of items) {\n  const j = item.json || {};\n  \n  // Skip processing if already blocked by validator\n  if (j.configError === true || j._isBlocked === true) {\n    out.push(item);\n    continue;\n  }\n  \n  // Validate score (handle NaN, Infinity, wrong types)\n  let score = 0;\n  const rawScore = j.score;\n  \n  if (typeof rawScore === 'number' && !isNaN(rawScore) && isFinite(rawScore)) {\n    score = Math.max(0, Math.min(100, rawScore));\n  } else if (typeof rawScore === 'string') {\n    const parsed = parseFloat(rawScore);\n    score = (!isNaN(parsed) && isFinite(parsed)) ? Math.max(0, Math.min(100, parsed)) : 0;\n  } else {\n    score = 0;\n  }\n  \n  if (score !== rawScore) {\n    console.warn(`Invalid score detected: ${rawScore}, normalized to ${score}`);\n  }\n  \n  const scoreBreakdown = j.scoreBreakdown ?? {};\n  const thresholds = j.thresholds || {};\n  \n  const ranges = (thresholds && thresholds.ranges) || {\n    allow: { min: 0, max: 29 },\n    sanitize_light: { min: 30, max: 55 },\n    sanitize_heavy: { min: 56, max: 75 },\n    block: { min: 76, max: 100 },\n  };\n\n  let decision = 'ALLOW';\n  if (score >= ranges.block.min) decision = 'BLOCK';\n  else if (score >= ranges.sanitize_heavy.min) decision = 'SANITIZE_HEAVY';\n  else if (score >= ranges.sanitize_light.min) decision = 'SANITIZE_LIGHT';\n\n  mergeDecision(j, decision, 'unified_decision_engine', {\n    score: score,\n    scoreBreakdown: scoreBreakdown,\n    reason: decision === 'ALLOW' ? 'OK' : 'POLICY'\n  });\n\n  item.json = j;\n  out.push(item);\n}\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3200,
        -976
      ],
      "id": "10be51fb-45ca-4a2a-8397-0177dc96b954",
      "name": "Unified Decision Engine"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Allowlist_Validator - FIXED: Better error handling, English messages\n */\n\nfunction nowIsoMs() { return new Date().toISOString(); }\n\nfunction mergeDecision(j, decision, source, extraMeta = {}) {\n  j.decision = j.decision || {};\n  Object.assign(j.decision, {\n    decision: decision,\n    source: source,\n    updated_at: nowIsoMs()\n  });\n  \n  j.__metadata = Object.assign({}, j.__metadata || {}, {\n    final_decision: decision,\n    decision_source: source,\n    ...extraMeta\n  });\n  \n  if (decision === 'BLOCK') {\n    j._isBlocked = true;\n  }\n}\n\nfunction validateJsonSchema(data, schema) {\n  if (!schema || !schema.required) return { valid: true, errors: [] };\n  \n  const errors = [];\n  for (const field of schema.required || []) {\n    if (!(field in data)) {\n      errors.push(`Missing required field: ${field}`);\n    }\n  }\n  \n  if (schema.properties) {\n    for (const [key, propSchema] of Object.entries(schema.properties)) {\n      if (key in data) {\n        const value = data[key];\n        const expectedType = Array.isArray(propSchema.type) ? propSchema.type : [propSchema.type];\n        const actualType = value === null ? 'null' : typeof value === 'object' && Array.isArray(value) ? 'array' : typeof value;\n        \n        if (!expectedType.includes(actualType) && !(expectedType.includes('null') && value === null)) {\n          errors.push(`Field ${key}: expected ${expectedType.join('|')}, got ${actualType}`);\n        }\n      }\n    }\n  }\n  \n  return { valid: errors.length === 0, errors };\n}\n\nconst items = $input.all();\nif (!items || items.length === 0) {\n  console.warn('Allowlist_Validator: No input items');\n  return [];\n}\n\nfor (const item of items) {\n  const j = item.json ?? {};\n  const schema = j.allowlist_schema || null;\n  \n  const hasInput = !!(j.chat_payload && typeof j.chat_payload.chatInput === \"string\" && j.chat_payload.chatInput.length >= 0);\n  \n  let schemaValid = true;\n  let schemaErrors = [];\n  \n  if (schema && hasInput) {\n    const validation = validateJsonSchema(j, schema);\n    schemaValid = validation.valid;\n    schemaErrors = validation.errors;\n  }\n  \n  const ok = hasInput && schemaValid;\n  \n  j.validation = {\n    ok,\n    errors: ok ? [] : [\n      ...(!hasInput ? [\"chat_payload_missing_or_invalid\"] : []),\n      ...schemaErrors\n    ],\n    enforced: true,\n    schemaVersion: schema ? (schema.$schema || \"unknown\") : \"none\",\n  };\n  \n  if (!ok) {\n    j.configError = true;\n    \n    mergeDecision(j, 'BLOCK', 'allowlist_validator', {\n      validation_failed: true,\n      validation_errors: j.validation.errors,\n      processingMs: 0\n    });\n    \n    if (j.config?.enforcement?.block_message) {\n      j.chat_payload = j.chat_payload || {};\n      j.chat_payload.chatInput = j.config.enforcement.block_message;\n    }\n  }\n  \n  item.json = j;\n}\n\nreturn items;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2672,
        -976
      ],
      "id": "446d41f8-1b26-4cda-9938-c9a0ecb84205",
      "name": "Allowlist_Validator"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Sanitization_Enforcement - FIXED: Better error handling, no throws\n */\n\nfunction nowIsoMs() { return new Date().toISOString(); }\n\nfunction mergeDecision(j, decision, source, extraMeta = {}) {\n  j.decision = j.decision || {};\n  Object.assign(j.decision, {\n    decision: decision,\n    source: source,\n    updated_at: nowIsoMs()\n  });\n  \n  j.__metadata = Object.assign({}, j.__metadata || {}, {\n    final_decision: decision,\n    decision_source: source,\n    ...extraMeta\n  });\n  \n  if (decision === 'BLOCK') {\n    j._isBlocked = true;\n  }\n}\n\nfunction applySanitize(text, patterns, redact) {\n  if (!patterns || !patterns.length) return { out: text, removedPct: 0, removedChars: 0 };\n  let out = text;\n  let removed = 0;\n  for (const p of patterns) {\n    try {\n      const re = new RegExp(p, \"giu\");\n      out = out.replace(re, (m) => {\n        removed += m.length;\n        return redact || \"\";\n      });\n    } catch (e) {\n      console.warn(`Invalid sanitization regex: ${p}`, e);\n    }\n  }\n  const removedPct = text.length ? Math.round((removed / text.length) * 100) : 0;\n  return { out, removedPct, removedChars: removed };\n}\n\nconst items = $input.all();\nif (!items || items.length === 0) {\n  console.warn('Sanitization_Enforcement: No input items');\n  return [];\n}\n\nfor (const item of items) {\n  const j = item.json ?? {};\n  const decision = j.decision?.decision || \"ALLOW\";\n\n  // FIXED: Better error handling\n  if (!j.config || !j.config.sanitization || !j.config.enforcement) {\n    console.error(\"Sanitization_Enforcement: Missing config.sanitization or config.enforcement\");\n    j.error = \"Missing sanitization config\";\n    j.decision = { decision: \"ALLOW\", reason: \"CONFIG_ERROR\" };\n    item.json = j;\n    continue;\n  }\n\n  const inText = j.chat_payload?.chatInput ?? j.chatInput ?? \"\";\n  const sessionId = j.sessionId ?? j.chat_payload?.sessionId ?? \"unknown\";\n  const action = j.action ?? j.chat_payload?.action ?? \"sendMessage\";\n\n  let finalText = inText;\n  let mode = \"none\";\n  let removalPct = 0;\n\n  j._pipeline_snapshots = j._pipeline_snapshots || {};\n  j._pipeline_snapshots.beforeSanitization = inText;\n\n  if (decision === \"SANITIZE_LIGHT\") {\n    if (!j.config.sanitization.light) {\n      console.error(\"Sanitization_Enforcement: Missing config.sanitization.light\");\n      finalText = inText;\n      mode = \"allow\";\n    } else {\n      const res = applySanitize(inText, j.config.sanitization.light.remove_patterns, j.config.sanitization.light.redact_token);\n      finalText = res.out;\n      removalPct = res.removedPct;\n      mode = \"light\";\n    }\n  } else if (decision === \"SANITIZE_HEAVY\") {\n    if (!j.config.sanitization.heavy) {\n      console.error(\"Sanitization_Enforcement: Missing config.sanitization.heavy\");\n      finalText = inText;\n      mode = \"allow\";\n    } else {\n      const heavyCfg = j.config.sanitization.heavy;\n      const res = applySanitize(inText, heavyCfg.remove_patterns, heavyCfg.redact_token);\n      removalPct = res.removedPct;\n      \n      const threshold = heavyCfg.max_removal_percent || 60;\n\n      if ((heavyCfg.policy || \"block_if_exceeds\") === \"block_if_exceeds\" && removalPct > threshold) {\n        mergeDecision(j, 'BLOCK', 'sanitization_enforcement', {\n          removal_pct: removalPct,\n          sanitizer_decision: 'SANITIZE_HEAVY',\n          blocked_by_sanitizer: true,\n          threshold_exceeded: threshold\n        });\n        \n        finalText = j.config.enforcement.block_message || \"Content blocked by security policy\";\n        mode = \"blocked\";\n      } else {\n        finalText = res.out;\n        mode = \"heavy\";\n      }\n    }\n  } else if (decision === \"BLOCK\") {\n    j._isBlocked = true;\n    finalText = j.config.enforcement?.block_message || \"Content blocked by security policy\";\n    mode = \"blocked\";\n  } else {\n    mode = \"allow\";\n  }\n\n  j.chat_payload = j.chat_payload || {};\n  j.chat_payload.sessionId = sessionId;\n  j.chat_payload.action = action;\n  j.chat_payload.chatInput = finalText;\n\n  j._pipeline_snapshots.afterSanitization = finalText;\n\n  j.enforcement = Object.assign({}, j.enforcement, {\n    mode,\n    removalPct\n  });\n\n  j.__san = {\n    sessionId,\n    action,\n    chat_payload: { sessionId, action, chatInput: finalText },\n    _pipeline_snapshots: {\n      beforeSanitization: j._pipeline_snapshots.beforeSanitization,\n      afterSanitization: j._pipeline_snapshots.afterSanitization\n    },\n    normalization: j.normalization,\n    enforcement: {\n      mode,\n      removalPct,\n      heavy_policy: j.config.sanitization.heavy?.policy || \"block_if_exceeds\",\n      heavy_threshold_pct: j.config.sanitization.heavy?.max_removal_percent\n    }\n  };\n\n  j.__metadata = j.__metadata || {};\n  const finalStatus = j.decision?.decision || \"ALLOW\";\n  j.__metadata.should_run_prompt_guard = (finalStatus !== \"BLOCK\");\n\n  item.json = j;\n}\n\nreturn items;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3744,
        -976
      ],
      "id": "3006174b-4add-4789-8759-082724f29f71",
      "name": "Sanitization_Enforcement"
    },
    {
      "parameters": {
        "jsCode": "/**\n * PII_Redactor - FIXED: English messages, proper error handling\n */\n\nconst items = $input.all();\nif (!items || items.length === 0) {\n  console.warn('PII_Redactor: No input items');\n  return [];\n}\n\nconst out = [];\n\nfor (const item of items) {\n  const j = item.json ?? {};\n  \n  if (j.configError === true || j._isBlocked === true) {\n    out.push(item);\n    continue;\n  }\n  \n  const piiConf = j.pii_conf;\n  if (!piiConf || !piiConf.rules) {\n    j.pii_error = \"PII_Redactor: missing pii_conf\";\n    item.json = j;\n    out.push(item);\n    continue;\n  }\n  \n  let text = j.chat_payload?.chatInput ?? j.chatInput ?? \"\";\n  \n  if (!text) {\n    j.pii_error = \"PII_Redactor: no text to redact\";\n    item.json = j;\n    out.push(item);\n    continue;\n  }\n  \n  let redactedText = text;\n  let redactionCount = 0;\n  const order = piiConf.order || piiConf.rules.map(r => r.name);\n  \n  for (const ruleName of order) {\n    const rule = piiConf.rules.find(r => r.name === ruleName);\n    if (!rule) continue;\n    \n    try {\n      const re = new RegExp(rule.pattern, rule.flags || 'giu');\n      const beforeText = redactedText;\n      \n      redactedText = redactedText.replace(re, rule.replacement);\n      \n      if (redactedText !== beforeText) {\n        redactionCount++;\n      }\n    } catch (e) {\n      console.warn(`PII regex failed for ${ruleName}:`, e.message);\n    }\n  }\n  \n  const hasPII = (redactedText !== text);\n  \n  if (hasPII) {\n    j.chat_payload = j.chat_payload || {};\n    j.chat_payload.chatInput = redactedText;\n  }\n  \n  j._pipeline_snapshots = j._pipeline_snapshots || {};\n  j._pipeline_snapshots.afterPII = redactedText;\n  \n  j.pii = {\n    redactedPreview: redactedText.substring(0, 200),\n    previewRedactionCount: redactionCount,\n    has: hasPII\n  };\n  \n  j.output_text_redacted = redactedText;\n  j.pii_error = null;\n  \n  item.json = j;\n  out.push(item);\n}\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1888,
        -976
      ],
      "id": "a3ad10c1-070a-44c3-9d62-2c4ce644d756",
      "name": "PII_Redactor"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Correlation_Engine - FIXED: Added items validation\n */\n\nfunction nowIsoMs() { return new Date().toISOString(); }\n\nfunction mergeDecision(j, decision, source, extraMeta = {}) {\n  j.decision = j.decision || {};\n  Object.assign(j.decision, {\n    decision: decision,\n    source: source,\n    updated_at: nowIsoMs()\n  });\n  \n  j.__metadata = Object.assign({}, j.__metadata || {}, {\n    final_decision: decision,\n    decision_source: source,\n    ...extraMeta\n  });\n  \n  if (decision === 'BLOCK') {\n    j._isBlocked = true;\n  }\n}\n\nconst items = $input.all();\nif (!items || items.length === 0) {\n  console.warn('Correlation_Engine: No input items');\n  return [];\n}\n\nfor (const item of items) {\n  const j = item.json ?? {};\n  \n  // Skip correlation if validation failed\n  if (j.configError === true) {\n    item.json = j;\n    continue;\n  }\n  \n  const sigs = j.normalization?.obfuscationSignals || [];\n  const dec = j.decision?.decision || \"ALLOW\";\n\n  let escalated = dec;\n  \n  if (sigs.includes(\"template-markers\")) {\n    escalated = \"BLOCK\";\n  }\n  else if (sigs.includes(\"math-alnum/fraktur\") || sigs.includes(\"mixed-latin-cyrillic\")) {\n    if (dec === \"ALLOW\") escalated = \"SANITIZE_LIGHT\";\n    else if (dec === \"SANITIZE_LIGHT\") escalated = \"SANITIZE_HEAVY\";\n    else if (dec === \"SANITIZE_HEAVY\") escalated = \"BLOCK\";\n  }\n\n  const correlationReason = escalated !== dec \n    ? `ESCALATED_FROM_${dec}_BY_SIGNALS_${sigs.join(',')}` \n    : (j.decision?.reason || 'POLICY');\n\n  j.correlation = { \n    signals: sigs, \n    before: dec, \n    after: escalated,\n    escalated: escalated !== dec\n  };\n  \n  mergeDecision(j, escalated, 'correlation_engine', {\n    correlation_applied: escalated !== dec,\n    correlation_signals: sigs,\n    previous_decision: dec,\n    reason: correlationReason,\n    escalated_by_correlation: escalated !== dec\n  });\n  \n  item.json = j;\n}\n\nreturn items;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3456,
        -976
      ],
      "id": "9b60a2d1-b773-44d9-9a97-aafaf33cd967",
      "name": "Correlation_Engine"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Pattern_Matching_Engine - FIXED: Proper regex handling\n */\n\nfunction safeRegex(pattern, flags) {\n  try {\n    // Patterns from JSON are already properly escaped - don't modify them!\n    return new RegExp(pattern, flags || 'giu');\n  } catch (e) {\n    console.warn(`Invalid regex pattern: ${pattern}`, e);\n    return null;\n  }\n}\n\nfunction calculateCategoryScore(baseWeight, multiplier, matchCount) {\n  if (matchCount === 0) return 0;\n  return Math.round(baseWeight * Math.pow(multiplier, matchCount - 1));\n}\n\nconst items = $input.all();\nif (!items || items.length === 0) {\n  console.warn('Pattern_Matching_Engine: No input items');\n  return [];\n}\n\nconst out = [];\n\nfor (const item of items) {\n  const j = item.json ?? {};\n  \n  if (j.configError === true || j._isBlocked === true) {\n    out.push(item);\n    continue;\n  }\n  \n  const text = j.normalization?.forScoring ?? j.chat_payload?.chatInput ?? \"\";\n  const rules = j.rules?.categories ?? {};\n  \n  if (!text) {\n    j.scoreBreakdown = {};\n    j.score = 0;\n    item.json = j;\n    out.push(item);\n    continue;\n  }\n  \n  const scoreBreakdown = {};\n  let totalScore = 0;\n  const matchDetails = [];\n  \n  for (const [categoryName, categoryData] of Object.entries(rules)) {\n    const { base_weight, multiplier, patterns } = categoryData;\n    \n    if (!patterns || !Array.isArray(patterns)) continue;\n    \n    let categoryMatchCount = 0;\n    const categoryMatches = [];\n    \n    for (const pattern of patterns) {\n      const re = safeRegex(pattern, 'giu');\n      if (!re) continue;\n      \n      re.lastIndex = 0;\n      const matches = text.match(re);\n      \n      if (matches && matches.length > 0) {\n        categoryMatchCount += matches.length;\n        categoryMatches.push({\n          pattern: pattern.substring(0, 50),\n          count: matches.length,\n          samples: matches.slice(0, 3).map(m => m.substring(0, 50) + (m.length > 50 ? '...' : ''))\n        });\n      }\n    }\n    \n    if (categoryMatchCount > 0) {\n      const categoryScore = calculateCategoryScore(base_weight, multiplier, categoryMatchCount);\n      scoreBreakdown[categoryName] = categoryScore;\n      totalScore += categoryScore;\n      \n      matchDetails.push({\n        category: categoryName,\n        matchCount: categoryMatchCount,\n        score: categoryScore,\n        matches: categoryMatches\n      });\n    }\n  }\n  \n  if (totalScore > 100) totalScore = 100;\n  \n  j.scoreBreakdown = scoreBreakdown;\n  j.score = totalScore;\n  j.matchDetails = matchDetails;\n  \n  item.json = j;\n  out.push(item);\n}\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2944,
        -976
      ],
      "id": "3ea174f4-c1ea-4d3b-9adb-650248e42679",
      "name": "Pattern_Matching_Engine"
    },
    {
      "parameters": {
        "operation": "text",
        "destinationKey": "data3",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        976,
        -384
      ],
      "id": "f488f82b-c6b2-45f9-8330-8f06b6149954",
      "name": "Extract from File2"
    },
    {
      "parameters": {
        "fileSelector": "=/home/node/config/pii.conf",
        "options": {
          "mimeType": "application/json",
          "dataPropertyName": "data"
        }
      },
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [
        800,
        -384
      ],
      "id": "ed1c274f-9800-48a0-bf90-d8c0823d4daa",
      "name": "Loading config files *.conf1"
    },
    {
      "parameters": {
        "operation": "text",
        "destinationKey": "data4",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        976,
        -176
      ],
      "id": "a43215b8-9680-4095-858c-9fd36a8967d2",
      "name": "Extract from File3"
    },
    {
      "parameters": {
        "fileSelector": "=/home/node/config/thresholds.config.json",
        "options": {
          "mimeType": "application/json",
          "dataPropertyName": "data"
        }
      },
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [
        800,
        -176
      ],
      "id": "9ca5c0f4-8163-47ae-9008-2dd1190fdc80",
      "name": "Loading config files *.conf2"
    },
    {
      "parameters": {
        "operation": "text",
        "destinationKey": "data5",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        976,
        32
      ],
      "id": "6c37004b-9099-4c6c-ac43-c233b0ba22fb",
      "name": "Extract from File4"
    },
    {
      "parameters": {
        "fileSelector": "=/home/node/config/unified_config.json",
        "options": {
          "mimeType": "application/json",
          "dataPropertyName": "data"
        }
      },
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [
        800,
        32
      ],
      "id": "6dfc1505-a326-424f-8428-2a5571cedad2",
      "name": "Loading config files *.conf3"
    },
    {
      "parameters": {
        "operation": "text",
        "destinationKey": "data6",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        976,
        240
      ],
      "id": "da4e3fde-f8bd-42f8-9427-3fe7e07eb8ec",
      "name": "Extract from File5"
    },
    {
      "parameters": {
        "fileSelector": "=/home/node/config/rules.config.json",
        "options": {
          "mimeType": "application/json",
          "dataPropertyName": "data"
        }
      },
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [
        800,
        240
      ],
      "id": "16e47978-0345-40d9-aea0-14945aed1f1b",
      "name": "Loading config files *.conf4"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Final Decision Node - BINARY CLASSIFICATION MODE\n * Updated for Llama Prompt Guard 2 (CRITICAL / MINIMAL only)\n * ADDED: output_text field for unified output logic\n */\n\nconst items = $input.all();\nif (!items || items.length === 0) {\n  throw new Error('Final Decision: No input items available');\n}\n\n// ========================================\n// HELPER FUNCTIONS\n// ========================================\n\nconst in01Regex = /(?:^|[^\\d])(1(?:\\.0+)?|0?\\.?\\d+|0)(?!\\d)/;\n\nfunction tryParse01(val) {\n  if (val === null || val === undefined) return null;\n  if (typeof val === 'number' && val >= 0 && val <= 1) return val;\n  const str = String(val);\n  const m = str.match(in01Regex);\n  if (!m) return null;\n  const v = parseFloat(m[1]);\n  return (v >= 0 && v <= 1) ? v : null;\n}\n\nfunction pickCtxItem(all) {\n  const fullConfigItem = all.find(it => {\n    const j = it?.json;\n    return j && j.config && j.rules && j.thresholds && j.chat_payload;\n  });\n  if (fullConfigItem) return fullConfigItem;\n  \n  const configItem = all.find(it => {\n    const j = it?.json;\n    return j && (j.config || j.data5);\n  });\n  if (configItem) return configItem;\n  \n  const restoredItem = all.find(it => {\n    const j = it?.json;\n    return j && j._llm_context_restored === true;\n  });\n  if (restoredItem) return restoredItem;\n  \n  return all[0];\n}\n\nfunction findPgScore(all) {\n  let score = null, src = null, raw = null;\n\n  for (const it of all) {\n    const j = it?.json;\n    \n    // Check for risk_score from Prompt Guard API\n    if (j && typeof j.risk_score === 'number') {\n      score = j.risk_score;\n      src = 'json.risk_score (Prompt Guard API)';\n      raw = j;\n      break;\n    }\n    \n    if (j && j.llm_result && typeof j.llm_result.score === 'number') {\n      score = j.llm_result.score;\n      src = 'llm_result.score (restored context)';\n      raw = j.llm_result.raw_output;\n      break;\n    }\n\n    if (typeof j === 'string') {\n      const v = tryParse01(j);\n      if (v !== null) { score = v; src = 'json:string'; raw = j; break; }\n    }\n\n    if (Array.isArray(j) && j.length) {\n      const first = j[0];\n      if (first && typeof first === 'object' && 'text' in first) {\n        const v = tryParse01(first.text);\n        if (v !== null) { score = v; src = 'array[0].text'; raw = first; break; }\n      } else {\n        const v = tryParse01(first);\n        if (v !== null) { score = v; src = 'array[0]'; raw = first; break; }\n      }\n    }\n\n    if (j && typeof j === 'object' && 'text' in j) {\n      const v = tryParse01(j.text);\n      if (v !== null) { score = v; src = 'json.text'; raw = j.text; break; }\n    }\n\n    if (j && j.data && Array.isArray(j.data) && j.data[0] && 'text' in j.data[0]) {\n      const v = tryParse01(j.data[0].text);\n      if (v !== null) { score = v; src = 'json.data[0].text'; raw = j.data[0].text; break; }\n    }\n\n    if (j && j.metrics && j.metrics.injectionScore !== undefined) {\n      const v = tryParse01(j.metrics.injectionScore);\n      if (v !== null) { score = v; src = 'json.metrics.injectionScore'; raw = j.metrics.injectionScore; break; }\n    }\n  }\n\n  if (score === null) { score = 0; src = 'default:0'; raw = null; }\n\n  return { score, src, raw };\n}\n\n// ========================================\n// MAIN LOGIC\n// ========================================\n\nconst ctxItem = pickCtxItem(items);\nconst { score: injectionScoreRaw, src: extractedFrom, raw: pgRaw } = findPgScore(items);\n\nlet config = ctxItem?.json?.config || ctxItem?.json?.data5;\n\nif (!config) {\n  const configFromOtherItem = items.find(it => it?.json?.config || it?.json?.data5);\n  \n  if (!configFromOtherItem) {\n    throw new Error(\n      'Final Decision: Missing config in all items. ' +\n      'Ensure Config Loader output is properly merged. ' +\n      'Available item keys: ' + \n      items.map((it, i) => `[${i}]: ${Object.keys(it?.json || {}).join(', ')}`).join(' | ')\n    );\n  }\n  \n  config = configFromOtherItem.json.config || configFromOtherItem.json.data5;\n  \n  if (!ctxItem.json.rules && configFromOtherItem.json.rules) {\n    ctxItem.json.rules = configFromOtherItem.json.rules;\n  }\n  if (!ctxItem.json.thresholds && configFromOtherItem.json.thresholds) {\n    ctxItem.json.thresholds = configFromOtherItem.json.thresholds;\n  }\n}\n\nconst promptGuardConfig = config.prompt_guard_policy;\nif (!promptGuardConfig) {\n  throw new Error('Final Decision: Missing config.prompt_guard_policy');\n}\n\nconst configEnabled = promptGuardConfig.enabled !== false;\nconst riskLevelsConfig = promptGuardConfig.risk_levels;\n\nif (!riskLevelsConfig) {\n  throw new Error('Final Decision: Missing config.prompt_guard_policy.risk_levels');\n}\n\n// Binary classification: only CRITICAL and MINIMAL required\nif (!riskLevelsConfig.CRITICAL) {\n  throw new Error('Final Decision: Missing config.prompt_guard_policy.risk_levels.CRITICAL');\n}\nif (!riskLevelsConfig.MINIMAL) {\n  throw new Error('Final Decision: Missing config.prompt_guard_policy.risk_levels.MINIMAL');\n}\n\nif (typeof riskLevelsConfig.CRITICAL.threshold_min !== 'number') {\n  throw new Error('Final Decision: Missing threshold_min for CRITICAL risk level');\n}\nif (typeof riskLevelsConfig.MINIMAL.threshold_min !== 'number') {\n  throw new Error('Final Decision: Missing threshold_min for MINIMAL risk level');\n}\nif (!riskLevelsConfig.CRITICAL.policy) {\n  throw new Error('Final Decision: Missing policy for CRITICAL risk level');\n}\nif (!riskLevelsConfig.MINIMAL.policy) {\n  throw new Error('Final Decision: Missing policy for MINIMAL risk level');\n}\n\nconst thresholds = {\n  critical: riskLevelsConfig.CRITICAL.threshold_min,\n  minimal: riskLevelsConfig.MINIMAL.threshold_min\n};\n\nconst policies = {\n  CRITICAL: riskLevelsConfig.CRITICAL.policy,\n  MINIMAL: riskLevelsConfig.MINIMAL.policy\n};\n\nif (!config.enforcement || !config.enforcement.block_message) {\n  throw new Error('Final Decision: Missing config.enforcement.block_message');\n}\nconst blockMessage = config.enforcement.block_message;\n\nlet injectionScore = Math.max(0, Math.min(1, injectionScoreRaw));\nlet riskLevel, severity;\n\n// Binary classification: CRITICAL (>=0.9) or MINIMAL (<0.9)\nif (injectionScore >= thresholds.critical) { \n  riskLevel = 'CRITICAL'; \n  severity = 5; \n} else { \n  riskLevel = 'MINIMAL'; \n  severity = 1; \n}\n\nconst configPolicy = policies[riskLevel];\nconst shouldBlockByPolicy = configPolicy === 'block';\n\nlet action, route, userMessage = null, internalNote;\n\nif (riskLevel === 'CRITICAL') {\n  if (shouldBlockByPolicy) {\n    action = 'BLOCK_IMMEDIATE'; \n    route = 'blocked';\n    userMessage = blockMessage;\n    internalNote = `Critical injection attempt detected by Prompt Guard (risk_score: ${injectionScore.toFixed(4)}) - blocked by policy=${configPolicy}`;\n  } else {\n    action = 'ALLOW_WITH_LOGGING'; \n    route = 'safe';\n    userMessage = null;\n    internalNote = `Critical risk detected (risk_score: ${injectionScore.toFixed(4)}) - allowed by policy=${configPolicy} (unusual config)`;\n  }\n} else {\n  // MINIMAL risk level\n  if (shouldBlockByPolicy) {\n    action = 'BLOCK_WITH_WARNING'; \n    route = 'blocked';\n    userMessage = blockMessage;\n    internalNote = `Minimal risk (risk_score: ${injectionScore < 0.01 ? injectionScore.toExponential(2) : injectionScore.toFixed(4)}) - blocked by policy=${configPolicy} (unusual config)`;\n  } else {\n    action = 'ALLOW'; \n    route = 'safe';\n    userMessage = null;\n    internalNote = `Safe request confirmed by Prompt Guard (risk_score: ${injectionScore < 0.01 ? injectionScore.toExponential(2) : injectionScore.toFixed(4)}) - allowed`;\n  }\n}\n\n// Check for sanitizer override\nconst previousDecision =\n  ctxItem?.json?.decision?.decision ||\n  ctxItem?.json?.__metadata?.final_decision ||\n  ctxItem?.json?.correlation?.after;\n\nif (previousDecision === 'BLOCK' || previousDecision === 'blocked' || ctxItem?.json?._isBlocked === true) {\n  route = 'blocked';\n  action = 'BLOCK_BY_SANITIZER';\n  userMessage = userMessage || blockMessage;\n  internalNote += ' | Forced block by sanitizer (previousDecision=' + previousDecision + ', _isBlocked=' + ctxItem?.json?._isBlocked + ')';\n}\n\n// ========================================\n// DETERMINE OUTPUT_TEXT\n// ========================================\n\nlet outputText;\n\nif (route === 'blocked') {\n  // BLOCKED: use block message\n  outputText = userMessage || blockMessage;\n} else {\n  // ALLOWED: use text after PII redaction\n  outputText = ctxItem?.json?._pipeline_snapshots?.afterPII ||\n               ctxItem?.json?.output_text_redacted ||\n               ctxItem?.json?.chat_payload?.chatInput ||\n               ctxItem?.json?.normalization?.canonical ||\n               'N/A';\n}\n\n// ========================================\n// BUILD RESULT\n// ========================================\n\nconst result = {\n  decision: {\n    action,\n    route,\n    severity,\n    riskLevel,\n    scoreRaw: injectionScore,\n    scorePercent: Math.round(injectionScore * 100),\n    scoreFormatted: injectionScore < 0.01 ? injectionScore.toExponential(2) : injectionScore.toFixed(4),\n    appliedPolicy: configPolicy,\n    model: 'Llama-Prompt-Guard-2-86M'\n  },\n  messages: {\n    user: userMessage,\n    internal: internalNote\n  },\n  routing: {\n    shouldBlock: route === 'blocked',\n    shouldWarn: false,\n    shouldLog: severity >= 2,\n    shouldSanitize: false,\n    isSafe: route === 'safe'\n  },\n  metrics: {\n    injectionScore,\n    scorePercent: Math.round(injectionScore * 100),\n    severity,\n    confidence: injectionScore > 0.9 || injectionScore < 0.1 ? 'high' : 'medium',\n    processingTime: Date.now()\n  },\n  technical: {\n    thresholdsUsed: thresholds,\n    policiesUsed: policies,\n    configEnabled: configEnabled,\n    pgRaw,\n    extractedFrom,\n    binaryClassification: true\n  },\n  audit: {\n    timestamp: new Date().toISOString(),\n    node: 'final_decision',\n    originalPrompt:\n      ctxItem?.json?.output_text_redacted ||\n      ctxItem?.json?.chatInput ||\n      ctxItem?.json?.input ||\n      ctxItem?.json?.chat_payload?.chatInput ||\n      'N/A',\n    llmScore: injectionScore,\n    finalDecision: action,\n    appliedPolicy: configPolicy,\n    configSource: 'unified_config.json',\n    previousDecision: previousDecision || 'none',\n    blockFlagSet: ctxItem?.json?._isBlocked === true,\n    promptGuardModel: 'Llama-Prompt-Guard-2-86M'\n  },\n  \n  __san: ctxItem?.json?.__san || {},\n  _pipeline_snapshots: ctxItem?.json?._pipeline_snapshots || {},\n  normalization: ctxItem?.json?.normalization || {},\n  chat_payload: ctxItem?.json?.chat_payload || {},\n  sessionId: ctxItem?.json?.sessionId || ctxItem?.json?.chat_payload?.sessionId || 'unknown',\n  action: ctxItem?.json?.action || ctxItem?.json?.chat_payload?.action || 'sendMessage',\n  config: config,\n  rules: ctxItem?.json?.rules || {},\n  thresholds: ctxItem?.json?.thresholds || {},\n  enforcement: ctxItem?.json?.enforcement || {},\n  _loader: ctxItem?.json?._loader || {},\n  score: ctxItem?.json?.score || 0,\n  scoreBreakdown: ctxItem?.json?.scoreBreakdown || {},\n  matchDetails: ctxItem?.json?.matchDetails || [],\n  sanitizer_decision: ctxItem?.json?.decision || {},\n  \n  // âœ“ UNIFIED OUTPUT FIELD\n  output_text: outputText,\n  \n  _route: route,\n  _shouldContinue: route === 'safe',\n  _requiresSanitization: false,\n  _isBlocked: route === 'blocked'\n};\n\nreturn [{\n  json: result,\n  binary: ctxItem?.binary || {}\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5392,
        -976
      ],
      "id": "1d05e36c-6097-4bb1-8bde-21e8f11a79bc",
      "name": "Finale Decision"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {
          "includeUnpaired": true
        }
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        5152,
        -976
      ],
      "id": "0d21ca31-ef03-464d-a45b-3a43fb4a6d43",
      "name": "Merge1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "36e14137-f077-4f9b-8bb7-0596338fa273",
              "leftValue": "={{ $json.decision?.decision }}",
              "rightValue": "BLOCK",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        3984,
        -976
      ],
      "id": "91de4760-1027-4c8d-a470-ba97e6885ac8",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n// Item 0: Context from Prepare Groq Request\n// Item 1: API response from Prompt Guard API\nconst contextItem = items[0];\nconst apiItem = items[1];\nconst j = contextItem.json;\nconst apiData = apiItem.json;\n\n// Extract risk_score from Prompt Guard API response\nlet riskScore = 0;\nlet llmRawOutput = null;\nlet llmVerdict = null;\nlet llmIsAttack = false;\nlet confidence = 0;\n\n// Handle Prompt Guard API format (NEW)\nif (apiData.risk_score !== undefined) {\n  riskScore = apiData.risk_score;\n  confidence = apiData.confidence || 0;\n  llmRawOutput = JSON.stringify({\n    text: apiData.text,\n    is_attack: apiData.is_attack,\n    risk_score: apiData.risk_score,\n    confidence: apiData.confidence,\n    verdict: apiData.verdict\n  });\n  llmVerdict = apiData.verdict;\n  llmIsAttack = apiData.is_attack;\n}\n// Fallback: Handle OLD format (confidence field)\nelse if (apiData.confidence !== undefined) {\n  riskScore = apiData.confidence;\n  confidence = apiData.confidence;\n  llmRawOutput = JSON.stringify(apiData);\n  llmVerdict = apiData.verdict;\n  llmIsAttack = apiData.is_attack;\n}\n// Fallback: Handle Groq format (choices array)\nelse if (apiData.choices && apiData.choices[0]) {\n  const content = apiData.choices[0].message?.content;\n  if (content) {\n    riskScore = parseFloat(content);\n    confidence = riskScore;\n    llmRawOutput = content;\n  }\n}\n\n// Ensure score is valid (0-1 range)\nif (isNaN(riskScore)) riskScore = 0;\nriskScore = Math.max(0, Math.min(1, riskScore));\n\n// Store result with risk_score as primary field\nj.risk_score = riskScore;\nj.llm_result = {\n  score: riskScore,\n  raw_output: llmRawOutput,\n  is_attack: llmIsAttack,\n  verdict: llmVerdict,\n  confidence: confidence,\n  source: 'meta-llama/llama-prompt-guard-2-86m',\n  timestamp: new Date().toISOString()\n};\n\nj._llm_context_restored = true;\ndelete j.api_payload;\n\nreturn [{ json: j, pairedItem: 0 }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4880,
        -864
      ],
      "id": "338e469a-6d8d-4f06-a4b7-a9e901887af1",
      "name": "LLM Context Restore"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const j = item.json;\n  \n  const content = j._pipeline_snapshots?.afterSanitization || \n                  j.chat_payload?.chatInput || \n                  \"test\";\n  \n  results.push({\n    json: {\n      ...j,\n      api_payload: {\n        model: \"meta-llama/llama-prompt-guard-2-86m\",\n        messages: [\n          {\n            role: \"user\",\n            content: content\n          }\n        ],\n        temperature: 0,\n        max_tokens: 10\n      }\n    },\n    pairedItem: item.pairedItem\n  });\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4272,
        -880
      ],
      "id": "0be04fd9-d33e-40fe-a23f-aa3ddaa1852b",
      "name": "Prepare Groq Request"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://prompt-guard-api:8000/detect",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "={{ $json.chatInput }}"
            }
          ]
        },
        "options": {
          "timeout": 15000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        4464,
        -752
      ],
      "id": "d3a0aeda-7c44-44df-aac6-1a6a21d7a2c9",
      "name": "Prompt Guard API"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        4656,
        -864
      ],
      "id": "9131862b-a161-4470-acbf-4971d17f951a",
      "name": "Merge2"
    },
    {
      "parameters": {
        "jsCode": "/**\n * BloomPrefilter - Configuration-driven implementation\n * All settings from unified_config.json\n */\n\nclass SimpleBloomFilter {\n  constructor(size = 32768, k = 5, seed = 1337) {\n    this.bits = new Uint8Array(size);\n    this.size = size;\n    this.k = k;\n    this.seed = seed;\n    this.itemCount = 0;\n  }\n  \n  hash(str, seed) {\n    let h = seed;\n    for (let i = 0; i < str.length; i++) {\n      h ^= str.charCodeAt(i);\n      h = Math.imul(h ^ (h >>> 16), 0x85ebca6b);\n      h = Math.imul(h ^ (h >>> 13), 0xc2b2ae35);\n      h ^= h >>> 16;\n    }\n    return h >>> 0;\n  }\n  \n  getHashes(item) {\n    const hashes = [];\n    for (let i = 0; i < this.k; i++) {\n      const h = this.hash(item, this.seed + i) % this.size;\n      hashes.push(h);\n    }\n    return hashes;\n  }\n  \n  add(item) {\n    const hashes = this.getHashes(item);\n    for (const h of hashes) {\n      this.bits[h] = 1;\n    }\n    this.itemCount++;\n  }\n  \n  test(item) {\n    const hashes = this.getHashes(item);\n    for (const h of hashes) {\n      if (this.bits[h] === 0) return false;\n    }\n    return true;\n  }\n  \n  estimateFalsePositiveRate() {\n    const bitsSet = this.bits.reduce((sum, bit) => sum + bit, 0);\n    const p = bitsSet / this.size;\n    return Math.pow(p, this.k);\n  }\n}\n\nconst DEFAULT_DANGEROUS_PATTERNS = [\n  'ignore all instructions',\n  'ignore previous instructions',\n  'disregard instructions',\n  'override system',\n  'you are now',\n  'act as dan',\n  'jailbreak',\n  'developer mode',\n  'godmode enabled',\n  'love pliny',\n  'im free',\n  'system prompt',\n  'reveal instructions'\n];\n\nconst items = $input.all();\nif (!items || items.length === 0) {\n  console.warn('BloomPrefilter: No input items');\n  return [];\n}\n\nconst out = [];\n\nfor (const item of items) {\n  const j = item.json ?? {};\n  \n  // Skip if already blocked\n  if (j.configError === true || j._isBlocked === true) {\n    out.push(item);\n    continue;\n  }\n  \n  const cfg = j.config ?? {};\n  \n  // Get configuration from unified_config.json with defaults\n  const bloomCfg = cfg.bloom || { \n    m: 32768, \n    k: 5, \n    seed: 1337,\n    match_mod: 97,\n    min_matched_bits: 2\n  };\n  \n  const prefilterCfg = cfg.prefilter || {\n    ngram: { min: 3, max: 6, prefix_window: 96 },\n    sample_limit: 800,\n    obf_signals: { min_count: 2 }\n  };\n  \n  // Get dangerous patterns from config or use defaults\n  const dangerousPatterns = (prefilterCfg.dangerous_patterns && Array.isArray(prefilterCfg.dangerous_patterns) && prefilterCfg.dangerous_patterns.length > 0) \n    ? prefilterCfg.dangerous_patterns \n    : DEFAULT_DANGEROUS_PATTERNS;\n    \n  const bloomDecisions = cfg.bloom_decisions || {\n    route_to_ac_threshold: 10,\n    hard_block_threshold: 50,\n    require_zusatz_signals: true\n  };\n  \n  // Initialize bloom filter\n  const bloom = new SimpleBloomFilter(bloomCfg.m, bloomCfg.k, bloomCfg.seed);\n  \n  // Add all dangerous patterns to bloom filter\n  for (const pattern of dangerousPatterns) {\n    if (typeof pattern === 'string' && pattern.length > 0) {\n      bloom.add(pattern.toLowerCase());\n    }\n  }\n  \n  const text = j.normalization?.forScoring ?? j.chat_payload?.chatInput ?? \"\";\n  const original = j.normalization?.original ?? \"\";\n  \n  // Skip if no text to analyze\n  if (!text) {\n    j.prefilter = {\n      bloom: { \n        matchedBitsCount: 0, \n        totalHashes: 0, \n        matchRatio: 0,\n        suspiciousScore: 0,\n        falsePositiveRate: 0,\n        patternsLoaded: dangerousPatterns.length,\n        skipped: true,\n        skipReason: 'no_text'\n      },\n      ngram: { sampledCount: 0 },\n      routeToAC: false,\n      hardBlock: false,\n      signals: {}\n    };\n    item.json = j;\n    out.push(item);\n    continue;\n  }\n  \n  // Extract n-grams from text for testing\n  const ngramMin = prefilterCfg.ngram?.min || 3;\n  const ngramMax = prefilterCfg.ngram?.max || 6;\n  const sampleLimit = prefilterCfg.sample_limit || 800;\n  \n  const testText = text.substring(0, sampleLimit).toLowerCase();\n  let matchedBits = 0;\n  let totalTests = 0;\n  \n  // Test various n-grams against bloom filter\n  for (let n = ngramMin; n <= ngramMax; n++) {\n    for (let i = 0; i <= testText.length - n; i++) {\n      const ngram = testText.substring(i, i + n);\n      totalTests++;\n      if (bloom.test(ngram)) {\n        matchedBits++;\n      }\n    }\n  }\n  \n  const matchRatio = totalTests > 0 ? matchedBits / totalTests : 0;\n  \n  // Additional cheap signals\n  const hasZWSP = /[\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\uFEFF]/.test(original);\n  const longBase64 = /\\b[A-Za-z0-9+/]{100,}={0,2}\\b/.test(text);\n  const hasTemplateMarkers = j.normalization?.obfuscationSignals?.includes(\"template-markers\") || false;\n  const hasSeparatorAbuse = j.normalization?.obfuscationSignals?.includes(\"separator-abuse\") || false;\n  \n  // Decision based on config thresholds\n  const suspiciousScore = matchRatio * 100;\n  const routeToAC = (suspiciousScore > bloomDecisions.route_to_ac_threshold) || \n                    hasTemplateMarkers || hasSeparatorAbuse;\n  \n  const hardBlock = (suspiciousScore > bloomDecisions.hard_block_threshold) && \n                    (!bloomDecisions.require_zusatz_signals || (hasZWSP || longBase64));\n  \n  j.prefilter = {\n    bloom: { \n      matchedBitsCount: matchedBits, \n      totalHashes: totalTests, \n      matchRatio: matchRatio,\n      suspiciousScore: Math.round(suspiciousScore),\n      falsePositiveRate: bloom.estimateFalsePositiveRate(),\n      patternsLoaded: dangerousPatterns.length,\n      configSource: (prefilterCfg.dangerous_patterns && prefilterCfg.dangerous_patterns.length > 0) ? 'config' : 'defaults'\n    },\n    ngram: { \n      sampledCount: Math.min(text.length, sampleLimit),\n      ngramMin,\n      ngramMax\n    },\n    routeToAC, \n    hardBlock,\n    signals: { hasZWSP, longBase64, hasTemplateMarkers, hasSeparatorAbuse },\n    thresholdsUsed: {\n      route_threshold: bloomDecisions.route_to_ac_threshold,\n      block_threshold: bloomDecisions.hard_block_threshold,\n      zusatz_required: bloomDecisions.require_zusatz_signals\n    }\n  };\n  \n  // If hard block detected, set decision early\n  if (hardBlock) {\n    j.decision = j.decision || {};\n    j.decision.decision = 'BLOCK';\n    j.decision.source = 'bloom_prefilter';\n    j.decision.reason = 'HIGH_RISK_PATTERN_DETECTED';\n    j.decision.details = {\n      suspiciousScore: Math.round(suspiciousScore),\n      signals: Object.keys(j.prefilter.signals).filter(k => j.prefilter.signals[k]),\n      matchRatio: matchRatio,\n      threshold: bloomDecisions.hard_block_threshold\n    };\n    j._isBlocked = true;\n  }\n  \n  item.json = j;\n  out.push(item);\n}\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        -976
      ],
      "id": "94e279fe-c3a3-4e59-bc2f-39c329f2f1c7",
      "name": "Bloom_Prefilter"
    }
  ],
  "pinData": {},
  "connections": {
    "When chat message received": {
      "main": [
        [
          {
            "node": "Keep only set",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build+Sanitize NDJSON": {
      "main": [
        [
          {
            "node": "Logging to Clikhouse",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Logging to Clikhouse": {
      "main": [
        [
          {
            "node": "Clean output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Config Loader": {
      "main": [
        [
          {
            "node": "PII_Redactor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Config Loader",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Keep only set": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          },
          {
            "node": "Loading config files *.json",
            "type": "main",
            "index": 0
          },
          {
            "node": "Loading config files *.conf",
            "type": "main",
            "index": 0
          },
          {
            "node": "Loading config files *.conf1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Loading config files *.conf2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Loading config files *.conf3",
            "type": "main",
            "index": 0
          },
          {
            "node": "Loading config files *.conf4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Extract from File1": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Normalize_Node": {
      "main": [
        [
          {
            "node": "Bloom_Prefilter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loading config files *.conf": {
      "main": [
        [
          {
            "node": "Extract from File1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loading config files *.json": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Unified Decision Engine": {
      "main": [
        [
          {
            "node": "Correlation_Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Allowlist_Validator": {
      "main": [
        [
          {
            "node": "Pattern_Matching_Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sanitization_Enforcement": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PII_Redactor": {
      "main": [
        [
          {
            "node": "Normalize_Node",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Correlation_Engine": {
      "main": [
        [
          {
            "node": "Sanitization_Enforcement",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pattern_Matching_Engine": {
      "main": [
        [
          {
            "node": "Unified Decision Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File2": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "Loading config files *.conf1": {
      "main": [
        [
          {
            "node": "Extract from File2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File3": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Loading config files *.conf2": {
      "main": [
        [
          {
            "node": "Extract from File3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File4": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 5
          }
        ]
      ]
    },
    "Loading config files *.conf3": {
      "main": [
        [
          {
            "node": "Extract from File4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File5": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 6
          }
        ]
      ]
    },
    "Loading config files *.conf4": {
      "main": [
        [
          {
            "node": "Extract from File5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finale Decision": {
      "main": [
        [
          {
            "node": "Build+Sanitize NDJSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Finale Decision",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Groq Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Context Restore": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Prepare Groq Request": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prompt Guard API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prompt Guard API": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge2": {
      "main": [
        [
          {
            "node": "LLM Context Restore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Bloom_Prefilter": {
      "main": [
        [
          {
            "node": "Allowlist_Validator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "35404a75-5236-4841-8883-0d932570cbae",
  "meta": {
    "instanceId": "c7631342988a1d00a0adbb0b039f33e694f16efba1c4f79c78249f2f9a39fb71"
  },
  "id": "Eodx58hxmadAS4Jx",
  "tags": []
}